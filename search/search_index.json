{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This is meant to be a repository of common high-throughput screening (HTS) tasks using the python programming language. It's probably somewhere in-between an introductory tutorial and a cookbook.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>This is going to assume some basic familiarity with python, such as what a function is, the basic data types such as integers, lists and dictionaries. The aim isn't to teach you python from scratch, but to teach python beginners how they can apply their new python knowledge to help them analyse HTS data.</p> <p>It's also going to assume you're somewhat familiar with typical HTS workflows and terminology, such as multi-well plates, IC50 values, z-scores etc.</p>"},{"location":"#python","title":"Python","text":"<p>The code in these tutorials uses python 3.10 and python's type-hints. This is optional, and the code will run the same without it. I prefer it for clarity and better IDE experience.</p> <p>The code snippets are written with an aim of clarity rather than numerical stability or handling edge-cases. Dealing with missing data or dividing by zero issues is a separate topic.</p>"},{"location":"#libraries","title":"Libraries","text":"<p>The code snippets will use a few external libraries, mainly from the scipy ecosystem:</p> <ul> <li>pandas</li> <li>numpy</li> <li>matplotlib</li> <li>scipy</li> </ul>"},{"location":"plates/","title":"Plates","text":"<p>If we consider a single plate, we can represent it in 2 main ways:</p> <ul> <li>A mapping of well-labels to values</li> <li>A 2D array representing values in the dimensions of a plate.</li> </ul>"},{"location":"plates/#mapping-well-label-to-values","title":"Mapping well label to values","text":""},{"location":"plates/#dataframe","title":"DataFrame","text":"<pre><code>from string import ascii_uppercase\nimport pandas as pd\nimport numpy as np\n# make well labels\nrows = ascii_uppercase[:16]\ncols = range(1, 25)\nwells = [f\"{r}{c:02}\" for r in rows for c in cols]\nvalues = np.random.randn(384)  # just random data\nplate_df = pd.DataFrame({\"well\": wells, \"val\": values})\nplate_df.head()\n</code></pre> well val 0 A01 0.454 1 A02 0.195 2 A03 1.639 3 A04 0.831 4 A05 0.277 ... <p>Dataframes are probably the most useful format as pandas enables easy transformations such as merging, filtering, sorting etc.</p>"},{"location":"plates/#dictionary","title":"Dictionary","text":"<pre><code>plate_dict = {well: val for well, val in zip(wells, values)}\n# print out first couple of well:value pairs\nfor well, value in list(plate_dict.items())[:5]:\nprint(well, value, sep=\": \")\n</code></pre> <pre><code>&gt; A01: -0.5348518247234555\n&gt; A02: -1.0802744081971545\n&gt; A03: -0.23594497461538594\n&gt; A04: -0.4214463113386894\n&gt; A05: -0.37864853878757504\n</code></pre> <p>Or look up a value for a single well <pre><code>plate_dict[\"A01\"]\n&gt; -0.5348518247234555\n</code></pre></p>"},{"location":"plates/#plate-arrays","title":"Plate arrays","text":"<p>If we want to convert a Dataframe of a plate into a 2D array:</p> <pre><code>plate_arr = np.empty((16, 24), dtype=float)\nplate_arr[:] = np.nan  # set all values to missing\nfor _, well, value in plate_df.itertuples():\n# get row, column indices from well label (0 indexed)\nrow_pos = ord(well[0])-65\ncol_pos = int(well[1:]) - 1\n# assign value to this index in array\nplate_arr[row_pos, col_pos] = value\n</code></pre>"},{"location":"plates/#plotting-a-plate","title":"Plotting a plate","text":"<p>With plates in their 2D array format, it is now very easy to plot these as a platemap with matplotlib.</p> <p><pre><code>import matplotlib.pyplot as plt\nfig, ax = plt.subplots(figsize=[8, 5])\nplt.imshow(plate_arr, origin=\"upper\", cmap=\"bwr\")\nplt.colorbar(shrink=0.6)\n# display row and column labels\nplt.yticks(range(16), ascii_uppercase[:16], fontfamily=\"monospace\")\nplt.xticks(range(24), [f\"{i:02}\" for i in range(1, 25)], fontfamily=\"monospace\")\n# move column labels to top\nax.xaxis.tick_top()\nplt.show()\n</code></pre> </p>"},{"location":"wells/","title":"Wells","text":""},{"location":"wells/#creating-well-labels-from-row-and-column-positions","title":"Creating well labels from row and column positions","text":"<p>If we have row and column positions, we can convert these into well-labels.</p> <pre><code>from string import ascii_uppercase\ndef row_col_to_well(row: int, col: int) -&gt; str:\nreturn f\"{ascii_uppercase[row-1]}{col:02}\" \n</code></pre> <pre><code>row_col_to_well(1, 1)\n&gt; \"A01\"\n</code></pre>"},{"location":"wells/#row-and-column-positions-from-well-labels","title":"Row and column positions from well labels","text":"<pre><code>def well_to_row_col(well: str) -&gt; tuple[int, int]:\nrow = ord(well[0].upper()) - 64\ncol = int(well[1:])\nreturn row, col\n</code></pre> <pre><code>well_to_row_col(\"A01\")\n&gt; (1, 1)\n</code></pre> <p>The strange thing here is <code>ord(..) - 64</code> , what is ord, and why subtract 64? <code>ord()</code> converts a character into it's unicode integer representation, and for unimportant reasons \"A\" is 65. So if you want A = 1, B = 2, etc, subtract 64.</p> <p>Instead of just returning a tuple, we can use a <code>NamedTuple</code>, so we can access the row and column values by name, rather than position.</p> <pre><code>from typing import NamedTuple\nclass Well(NamedTuple):\nlabel: str\nrow: int\ncolumn: int\ndef make_well(well: str) -&gt; Well:\nrow, column = well_to_row_col(well)\nreturn Well(well, row, column)\n</code></pre> <pre><code>make_well(\"A01\")\n&gt;  Well(label='A01', row=1, column=1)\n</code></pre>"},{"location":"wells/#zero-padding-well-labels","title":"Zero padding well labels","text":"<p>Wells are typically zero-padded, such as \"A01\" rather than \"A1\", but we sometimes have to convert well labels between the two.</p> <p>This uses python string formatting, which can handily format integers as strings with zero padding for us.</p> <pre><code>def pad_well(well: str) -&gt; str:\nrow = well[0]\ncol = int(well[1:])\nreturn f\"{row}{col:02}\"\n</code></pre> <pre><code>pad_well(\"A1\")\n&gt; \"A01\"\n</code></pre> <p>So the magic is done in <code>{col:02}</code>. This means the <code>col</code> number, and everything after the colon is the fomatting specifications, in this case we want 2 digits, zero-padded if necessary <code>:02</code>.</p> <p>Unpadding wells is almost identical, except we don't specify any special formatting in <code>{col}</code>.</p> <pre><code>def unpad_well(well: str) -&gt; str:\nrow = well[0]\ncol = int(well[1:])\nreturn f\"{row}{col}\"\n</code></pre> <pre><code>unpad_well(\"A01\")\n&gt; \"A1\"\n</code></pre>"},{"location":"wells/#generating-a-well-labels","title":"Generating a well labels","text":"<p>If we wanted to generate all the well labels in a 384-well plate: <pre><code>from string import ascii_uppercase\nwells = [f\"{r}{c:02}\" for r in ascii_uppercase[:16] for c in range(1, 25)]\n</code></pre></p> <p>It's worth noting that python's <code>range(1, 25)</code> function is not inclusive of the final number in the sequence, that's why we went to 25 and not 24.</p>"},{"location":"wells/#wells-from-1536-well-plates","title":"Wells from 1536 well plates","text":"<p>A 1536 well plate has 48 columns and 32 rows. The key difference is the 32 rows which cannot be represented as a single alphabetical character. The most common 1536 well plate formats have rows which range from A-Z, and then continue from AA until AF. So our previous python functions will break with wells from a 1536-well plate.</p> <p></p> <pre><code>from string import ascii_uppercase\ndef row_col_to_well(row: int, col: int) -&gt; str:\nif row &lt;= 26:\nrow_letter = ascii_uppercase[row - 1]\nelse:\nrow_letter = \"A\" + ascii_uppercase[row % (26 + 1)]\nreturn f\"{row_letter}{col:02}\"\n</code></pre> <p>We now can't assume the first character of the well label corresponds to the row, it might be one character (A-Z), or 2 character (AA-AF). But we can index  the well label starting from the end, so we never have to worry about that. So the last 2 characters (<code>well[-2:]</code>) are always the column (if zero-padded), and from there until the start of the well-label (<code>well[:-2]</code>) is the row, whether it's 1 character or 2.</p> <p>We then need to convert the row character(s) into an integer. Before we used the <code>ord()</code> function to convert the character into a numerical representation. Now we have to handle either \"A\" or \"AA\", which means either row 1 or row 27. The simplest way is to check the length, if it's only 1 character, treat it the usual way, if it's 2 characters, get the number of the last character and add 26 (or to save an operation, subtract 38 instead of the usual 64 from the <code>ord()</code> function).</p> <pre><code>def well_to_row_col(well: str) -&gt; tuple[int, int]:\ncol = int(well[-2:])  # last 2 characters as an integer\nrow_char = well[:-2]  # up until the last 2 characters\nif len(row_char) == 1:\nrow = ord(row_char.upper()) - 64\nelse:\nrow = ord(row_char[-1].upper()) - 38  # (65 - 26 = 38)\nreturn row, col\n</code></pre> <p>We could also solve this issue using regular expressions but they're usually more trouble than they're worth.</p>"},{"location":"quality_control/z_prime/","title":"Z prime","text":""},{"location":"quality_control/z_prime/#standard-z","title":"Standard Z`","text":"<p>Z prime is used as a quality control metric to measure the separation between positive and negative controls.</p> \\[ {\\displaystyle {\\text{Z`}}=1-{3(\\sigma _{p}+\\sigma _{n}) \\over |\\mu _{p}-\\mu _{n}|}} \\] <p>Where \\(\\mu_p\\) and \\(\\mu_n\\) are the mean of the positive and negative controls, and \\(\\sigma_p\\) and \\(\\sigma_n\\) are the standard deviations of the positive and negative controls. A value greater than 0.5 is typically considered good.</p> <p>To calculate the Z` between a list of positive control values and negative control values: <pre><code>import numpy as np\ndef z_prime(pos: list, neg: list) -&gt; float:\nsigma_p, sigma_n = np.std(pos), np.std(neg)\nmu_p, mu_n = np.mean(pos), np.mean(neg)\nreturn 1 - (3 * (sigma_p + sigma_n) / np.abs(mu_p - mu_n))\n</code></pre></p>"},{"location":"quality_control/z_prime/#robust-z","title":"Robust Z`","text":"<p>The robust Z prime is the same calculation as before, but using the median instead of mean, and median absolute deviation instead of standard deviation.</p> <pre><code>import numpy as np\nfrom scipy.stats import median_abs_deviation as mad\ndef robust_z_prime(pos: list, neg: list) -&gt; float:\nsigma_p, sigma_n = mad(pos), mad(neg)\nmu_p, mu_n = np.median(pos), np.median(neg)\nreturn 1 - (3 * (sigma_p + sigma_n) / np.abs(mu_p - mu_n))\n</code></pre>"}]}