{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Python for high throughput screening (HTS).</p> <p>How to perform common HTS tasks in python.</p> <p>A work in progress.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":"<p>This is going to assume some basic familiarity with python, such as what a function is, the basic data types such as integers, lists and dictionaries. The aim isn't to teach you python from scratch, but to teach python beginners how they can apply their new python knowledge to help them analyse HTS data.</p> <p>It's also going to assume you're somewhat familiar with typical HTS workflows and terminology, such as multi-well plates, IC50 values, z-scores etc.</p>"},{"location":"#python","title":"Python","text":"<p>The code in these tutorials uses python 3.10 and python's type-hints. This is optional, and the code will run the same without it. I prefer it for clarity and better IDE experience.</p>"},{"location":"#libraries","title":"Libraries","text":"<p>The code snippets will use a few external libraries, mainly from the scipy ecosystem:</p> <ul> <li>pandas</li> <li>numpy</li> <li>matplotlib</li> <li>scipy</li> </ul>"},{"location":"plates/","title":"Plates","text":"<p>If we consider a single plate, we can represent it in 2 main ways:</p> <ul> <li>A mapping of well-labels to values</li> <li>A 2D array representing values in the dimensions of a plate.</li> </ul>"},{"location":"plates/#mapping-well-label-to-values","title":"Mapping well label to values","text":""},{"location":"plates/#dataframe","title":"DataFrame","text":"<pre><code>from string import ascii_uppercase\nimport pandas as pd\nimport numpy as np\n# make well labels\nrows = ascii_uppercase[:16]\ncols = range(1, 25)\nwells = [f\"{r}{c:02}\" for r in rows for c in cols]\nvalues = np.random.randn(384)  # just random data\nplate_df = pd.DataFrame({\"well\": wells, \"val\": values})\nplate_df.head()\n</code></pre> well val 0 A01 0.454 1 A02 0.195 2 A03 1.639 3 A04 0.831 4 A05 0.277 ... <p>Dataframes are probably the most useful format as pandas enables easy transformations such as merging, filtering, sorting etc.</p>"},{"location":"plates/#dictionary","title":"Dictionary","text":"<pre><code>plate_dict = {well: val for well, val in zip(wells, values)}\n# print out first couple of well:value pairs\nfor well, value in list(plate_dict.items())[:5]:\nprint(well, value, sep=\": \")\n</code></pre> <pre><code>&gt; A01: -0.5348518247234555\n&gt; A02: -1.0802744081971545\n&gt; A03: -0.23594497461538594\n&gt; A04: -0.4214463113386894\n&gt; A05: -0.37864853878757504\n</code></pre> <p>Or look up a value for a single well <pre><code>plate_dict[\"A01\"]\n&gt; -0.5348518247234555\n</code></pre></p>"},{"location":"plates/#plate-arrays","title":"Plate arrays","text":"<p>If we want to convert a Dataframe of a plate into a 2D array:</p> <pre><code>plate_arr = np.empty((16, 24), dtype=float)\nplate_arr[:] = np.nan  # set all values to missing\nfor _, well, value in plate_df.itertuples():\n# get row, column indices from well label (0 indexed)\nrow_pos = ord(well[0])-65\ncol_pos = int(well[1:]) - 1\n# assign value to this index in array\nplate_arr[row_pos, col_pos] = value\n</code></pre>"},{"location":"plates/#plotting-a-plate","title":"Plotting a plate","text":"<p>With plates in their 2D array format, it is now very easy to plot these as a platemap with matplotlib.</p> <p><pre><code>import matplotlib.pyplot as plt\nfig, ax = plt.subplots(figsize=[8, 5])\nplt.imshow(plate_arr, origin=\"upper\", cmap=\"bwr\")\nplt.colorbar(shrink=0.6)\n# display row and column labels\nplt.yticks(range(16), ascii_uppercase[:16], fontfamily=\"monospace\")\nplt.xticks(range(24), [f\"{i:02}\" for i in range(1, 25)], fontfamily=\"monospace\")\n# move column labels to top\nax.xaxis.tick_top()\nplt.show()\n</code></pre> </p>"},{"location":"wells/","title":"Wells","text":""},{"location":"wells/#creating-well-labels-from-row-and-column-positions","title":"Creating well labels from row and column positions","text":"<p>If we have row and column positions, we can convert these into well-labels.</p> <pre><code>from string import ascii_uppercase\ndef row_col_to_well(row: int, col: int) -&gt; str:\nreturn f\"{ascii_uppercase[row-1]}{col:02}\" \n</code></pre> <pre><code>row_col_to_well(1, 1)\n&gt; \"A01\"\n</code></pre>"},{"location":"wells/#row-and-column-positions-from-well-labels","title":"Row and column positions from well labels","text":"<pre><code>def well_to_row_col(well: str) -&gt; tuple[int, int]:\nrow = ord(well[0].upper()) - 64\ncol = int(well[1:])\nreturn row, col\n</code></pre> <pre><code>well_to_row_col(\"A01\")\n&gt; (1, 1)\n</code></pre> <p>Instead of just returning a tuple, we can use a <code>NamedTuple</code>, so we can access the row and column values by name, rather than position.</p> <pre><code>from typing import NamedTuple\nclass Well(NamedTuple):\nlabel: str\nrow: int\ncolumn: int\ndef make_well(well: str) -&gt; Well:\nrow, column = well_to_row_col(well)\nreturn Well(well, row, column)\n</code></pre> <pre><code>make_well(\"A01\")\n&gt;  Well(label='A01', row=1, column=1)\n</code></pre>"},{"location":"wells/#zero-padding-well-labels","title":"Zero padding well labels","text":"<p>Wells are typically zero-padded, such as \"A01\" rather than \"A1\", but we sometimes have to convert well labels between the two.</p> <p>This uses python string formatting, which can handily format integers as strings with zero padding for us.</p> <pre><code>def pad_well(well: str) -&gt; str:\nrow = well[0]\ncol = int(well[1:])\nreturn f\"{row}{col:02}\"\n</code></pre> <pre><code>pad_well(\"A1\")\n&gt; \"A01\"\n</code></pre> <p>So the magic is done in <code>{col:02}</code>. This means the <code>col</code> number, and everything after the colon is the fomatting specifications, in this case we want 2 digits, zero-padded if necessary <code>:02</code>.</p> <p>Unpadding wells is almost identical, except we don't specify any special formatting in <code>{col}</code>.</p> <pre><code>def unpad_well(well: str) -&gt; str:\nrow = well[0]\ncol = int(well[1:])\nreturn f\"{row}{col}\"\n</code></pre> <pre><code>unpad_well(\"A01\")\n&gt; \"A1\"\n</code></pre>"},{"location":"wells/#generating-a-well-labels","title":"Generating a well labels","text":"<p>If we wanted to generate all the well labels in a 384-well plate: <pre><code>from string import ascii_uppercase\nwells = [f\"{r}{c:02}\" for r in ascii_uppercase[:16] for c in range(1, 25)]\n</code></pre></p> <p>It's worth noting that python's <code>range(1, 25)</code> function is not inclusive of the final number in the sequence, that's why we went to 25 and not 24.</p>"},{"location":"wells/#1536-well-plates","title":"1536 well plates","text":"<p>TODO</p>"},{"location":"Quality%20Control/z_prime/","title":"Z prime","text":""},{"location":"Quality%20Control/z_prime/#standard-z","title":"Standard Z`","text":"<p>Z prime is used as a quality control metric to measure the separation between positive and negative controls.</p> \\[ {\\displaystyle {\\text{Z`}}=1-{3(\\sigma _{p}+\\sigma _{n}) \\over |\\mu _{p}-\\mu _{n}|}} \\] <p>Where \\(\\mu_p\\) and \\(\\mu_n\\) are the mean of the positive and negative controls, and \\(\\sigma_p\\) and \\(\\sigma_n\\) are the standard deviations of the positive and negative controls. A value greater than 0.5 is typically considered good.</p> <p>To calculate the Z` between a list of positive control values and negative control values: <pre><code>import numpy as np\ndef z_prime(pos: list, neg: list) -&gt; float:\nsigma_p, sigma_n = np.std(pos), np.std(neg)\nmu_p, mu_n = np.mean(pos), np.mean(neg)\nreturn 1 - (3 * (sigma_p + sigma_n) / np.abs(mu_p - mu_n))\n</code></pre></p>"},{"location":"Quality%20Control/z_prime/#robust-z","title":"Robust Z`","text":"<p>The robust Z prime is the same calculation as before, but using the median instead of mean, and median absolute deviation instead of standard deviation.</p> <pre><code>import numpy as np\nfrom scipy.stats import median_abs_deviation as mad\ndef robust_z_prime(pos: list, neg: list) -&gt; float:\nsigma_p, sigma_n = mad(pos), mad(neg)\nmu_p, mu_n = np.median(pos), np.median(neg)\nreturn 1 - (3 * (sigma_p + sigma_n) / np.abs(mu_p - mu_n))\n</code></pre>"}]}